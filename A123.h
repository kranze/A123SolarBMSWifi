/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 36.5.0 Thu Feb 23 17:16:11 2023.
 */

#ifndef A123_H
#define A123_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define A123_M01_N_STD_FRAME_ID (0x200u)
#define A123_M01_N_XD1_FRAME_ID (0x300u)
#define A123_M01_N_XD2_FRAME_ID (0x380u)
#define A123_M02_P_STD_FRAME_ID (0x201u)
#define A123_M02_P_XD1_FRAME_ID (0x301u)
#define A123_M02_P_XD2_FRAME_ID (0x381u)
#define A123_M03_N_STD_FRAME_ID (0x202u)
#define A123_M03_N_XD1_FRAME_ID (0x302u)
#define A123_M03_N_XD2_FRAME_ID (0x382u)
#define A123_M04_P_STD_FRAME_ID (0x203u)
#define A123_M04_P_XD1_FRAME_ID (0x303u)
#define A123_M04_P_XD2_FRAME_ID (0x383u)
#define A123_M05_N_STD_FRAME_ID (0x204u)
#define A123_M05_N_XD1_FRAME_ID (0x304u)
#define A123_M05_N_XD2_FRAME_ID (0x384u)
#define A123_M06_P_STD_FRAME_ID (0x205u)
#define A123_M06_P_XD1_FRAME_ID (0x305u)
#define A123_M06_P_XD2_FRAME_ID (0x385u)
#define A123_M07_N_STD_FRAME_ID (0x206u)
#define A123_M07_N_XD1_FRAME_ID (0x306u)
#define A123_M07_N_XD2_FRAME_ID (0x386u)
#define A123_M08_P_STD_FRAME_ID (0x207u)
#define A123_M08_P_XD1_FRAME_ID (0x307u)
#define A123_M08_P_XD2_FRAME_ID (0x387u)
#define A123_M09_N_STD_FRAME_ID (0x208u)
#define A123_M09_N_XD1_FRAME_ID (0x308u)
#define A123_M09_N_XD2_FRAME_ID (0x388u)
#define A123_M10_P_STD_FRAME_ID (0x209u)
#define A123_M10_P_XD1_FRAME_ID (0x309u)
#define A123_M10_P_XD2_FRAME_ID (0x389u)
#define A123_M11_N_STD_FRAME_ID (0x20au)
#define A123_M11_N_XD1_FRAME_ID (0x30au)
#define A123_M11_N_XD2_FRAME_ID (0x38au)
#define A123_M12_P_STD_FRAME_ID (0x20bu)
#define A123_M12_P_XD1_FRAME_ID (0x30bu)
#define A123_M12_P_XD2_FRAME_ID (0x38bu)
#define A123_M13_N_STD_FRAME_ID (0x20cu)
#define A123_M13_N_XD1_FRAME_ID (0x30cu)
#define A123_M13_N_XD2_FRAME_ID (0x38cu)
#define A123_M14_P_STD_FRAME_ID (0x20du)
#define A123_M14_P_XD1_FRAME_ID (0x30du)
#define A123_M14_P_XD2_FRAME_ID (0x38du)
#define A123_M15_N_STD_FRAME_ID (0x20eu)
#define A123_M15_N_XD1_FRAME_ID (0x30eu)
#define A123_M15_N_XD2_FRAME_ID (0x38eu)
#define A123_BCM_CMD_FRAME_ID (0x50u)
#define A123_BCM_DIAG_REQ_FRAME_ID (0x7b0u)
#define A123_BCM_DIAG_RSP_FRAME_ID (0x7b8u)
#define A123_BCM_IDENTIFY_POR_FRAME_ID (0x666u)

/* Frame lengths in bytes. */
#define A123_M01_N_STD_LENGTH (8u)
#define A123_M01_N_XD1_LENGTH (8u)
#define A123_M01_N_XD2_LENGTH (8u)
#define A123_M02_P_STD_LENGTH (8u)
#define A123_M02_P_XD1_LENGTH (8u)
#define A123_M02_P_XD2_LENGTH (8u)
#define A123_M03_N_STD_LENGTH (8u)
#define A123_M03_N_XD1_LENGTH (8u)
#define A123_M03_N_XD2_LENGTH (8u)
#define A123_M04_P_STD_LENGTH (8u)
#define A123_M04_P_XD1_LENGTH (8u)
#define A123_M04_P_XD2_LENGTH (8u)
#define A123_M05_N_STD_LENGTH (8u)
#define A123_M05_N_XD1_LENGTH (8u)
#define A123_M05_N_XD2_LENGTH (8u)
#define A123_M06_P_STD_LENGTH (8u)
#define A123_M06_P_XD1_LENGTH (8u)
#define A123_M06_P_XD2_LENGTH (8u)
#define A123_M07_N_STD_LENGTH (8u)
#define A123_M07_N_XD1_LENGTH (8u)
#define A123_M07_N_XD2_LENGTH (8u)
#define A123_M08_P_STD_LENGTH (8u)
#define A123_M08_P_XD1_LENGTH (8u)
#define A123_M08_P_XD2_LENGTH (8u)
#define A123_M09_N_STD_LENGTH (8u)
#define A123_M09_N_XD1_LENGTH (8u)
#define A123_M09_N_XD2_LENGTH (8u)
#define A123_M10_P_STD_LENGTH (8u)
#define A123_M10_P_XD1_LENGTH (8u)
#define A123_M10_P_XD2_LENGTH (8u)
#define A123_M11_N_STD_LENGTH (8u)
#define A123_M11_N_XD1_LENGTH (8u)
#define A123_M11_N_XD2_LENGTH (8u)
#define A123_M12_P_STD_LENGTH (8u)
#define A123_M12_P_XD1_LENGTH (8u)
#define A123_M12_P_XD2_LENGTH (8u)
#define A123_M13_N_STD_LENGTH (8u)
#define A123_M13_N_XD1_LENGTH (8u)
#define A123_M13_N_XD2_LENGTH (8u)
#define A123_M14_P_STD_LENGTH (8u)
#define A123_M14_P_XD1_LENGTH (8u)
#define A123_M14_P_XD2_LENGTH (8u)
#define A123_M15_N_STD_LENGTH (8u)
#define A123_M15_N_XD1_LENGTH (8u)
#define A123_M15_N_XD2_LENGTH (8u)
#define A123_BCM_CMD_LENGTH (8u)
#define A123_BCM_DIAG_REQ_LENGTH (8u)
#define A123_BCM_DIAG_RSP_LENGTH (8u)
#define A123_BCM_IDENTIFY_POR_LENGTH (3u)

/* Extended or standard frame types. */
#define A123_M01_N_STD_IS_EXTENDED (0)
#define A123_M01_N_XD1_IS_EXTENDED (0)
#define A123_M01_N_XD2_IS_EXTENDED (0)
#define A123_M02_P_STD_IS_EXTENDED (0)
#define A123_M02_P_XD1_IS_EXTENDED (0)
#define A123_M02_P_XD2_IS_EXTENDED (0)
#define A123_M03_N_STD_IS_EXTENDED (0)
#define A123_M03_N_XD1_IS_EXTENDED (0)
#define A123_M03_N_XD2_IS_EXTENDED (0)
#define A123_M04_P_STD_IS_EXTENDED (0)
#define A123_M04_P_XD1_IS_EXTENDED (0)
#define A123_M04_P_XD2_IS_EXTENDED (0)
#define A123_M05_N_STD_IS_EXTENDED (0)
#define A123_M05_N_XD1_IS_EXTENDED (0)
#define A123_M05_N_XD2_IS_EXTENDED (0)
#define A123_M06_P_STD_IS_EXTENDED (0)
#define A123_M06_P_XD1_IS_EXTENDED (0)
#define A123_M06_P_XD2_IS_EXTENDED (0)
#define A123_M07_N_STD_IS_EXTENDED (0)
#define A123_M07_N_XD1_IS_EXTENDED (0)
#define A123_M07_N_XD2_IS_EXTENDED (0)
#define A123_M08_P_STD_IS_EXTENDED (0)
#define A123_M08_P_XD1_IS_EXTENDED (0)
#define A123_M08_P_XD2_IS_EXTENDED (0)
#define A123_M09_N_STD_IS_EXTENDED (0)
#define A123_M09_N_XD1_IS_EXTENDED (0)
#define A123_M09_N_XD2_IS_EXTENDED (0)
#define A123_M10_P_STD_IS_EXTENDED (0)
#define A123_M10_P_XD1_IS_EXTENDED (0)
#define A123_M10_P_XD2_IS_EXTENDED (0)
#define A123_M11_N_STD_IS_EXTENDED (0)
#define A123_M11_N_XD1_IS_EXTENDED (0)
#define A123_M11_N_XD2_IS_EXTENDED (0)
#define A123_M12_P_STD_IS_EXTENDED (0)
#define A123_M12_P_XD1_IS_EXTENDED (0)
#define A123_M12_P_XD2_IS_EXTENDED (0)
#define A123_M13_N_STD_IS_EXTENDED (0)
#define A123_M13_N_XD1_IS_EXTENDED (0)
#define A123_M13_N_XD2_IS_EXTENDED (0)
#define A123_M14_P_STD_IS_EXTENDED (0)
#define A123_M14_P_XD1_IS_EXTENDED (0)
#define A123_M14_P_XD2_IS_EXTENDED (0)
#define A123_M15_N_STD_IS_EXTENDED (0)
#define A123_M15_N_XD1_IS_EXTENDED (0)
#define A123_M15_N_XD2_IS_EXTENDED (0)
#define A123_BCM_CMD_IS_EXTENDED (0)
#define A123_BCM_DIAG_REQ_IS_EXTENDED (0)
#define A123_BCM_DIAG_RSP_IS_EXTENDED (0)
#define A123_BCM_IDENTIFY_POR_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define A123_M01_N_STD_M01N_T0_OOR_LO_CHOICE (254u)
#define A123_M01_N_STD_M01N_T0_OOR_HI_CHOICE (255u)

#define A123_M01_N_STD_M01N_T1_OOR_LO_CHOICE (254u)
#define A123_M01_N_STD_M01N_T1_OOR_HI_CHOICE (255u)

#define A123_M01_N_STD_M01N_T2_OOR_LO_CHOICE (254u)
#define A123_M01_N_STD_M01N_T2_OOR_HI_CHOICE (255u)

#define A123_M01_N_STD_M01N_T3_OOR_LO_CHOICE (254u)
#define A123_M01_N_STD_M01N_T3_OOR_HI_CHOICE (255u)

#define A123_M01_N_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M01_N_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M01_N_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M01_N_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M01_N_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M01_N_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M01_N_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M01_N_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M01_N_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M01_N_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M01_N_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M01_N_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M01_N_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M01_N_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M01_N_XD1_M01N_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M01_N_XD1_M01N_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M01_N_XD1_M01N_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M01_N_XD1_M01N_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M01_N_XD1_M01N_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M01_N_XD1_M01N_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M01_N_XD1_M01N_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M01_N_XD1_M01N_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M01_N_XD2_M01N_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M01_N_XD2_M01N_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M01_N_XD2_M01N_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M01_N_XD2_M01N_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M01_N_XD2_M01N_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M01_N_XD2_M01N_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M01_N_XD2_M01N_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M01_N_XD2_M01N_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M02_P_STD_M02P_T0_OOR_LO_CHOICE (254u)
#define A123_M02_P_STD_M02P_T0_OOR_HI_CHOICE (255u)

#define A123_M02_P_STD_M02P_T1_OOR_LO_CHOICE (254u)
#define A123_M02_P_STD_M02P_T1_OOR_HI_CHOICE (255u)

#define A123_M02_P_STD_M02P_T2_OOR_LO_CHOICE (254u)
#define A123_M02_P_STD_M02P_T2_OOR_HI_CHOICE (255u)

#define A123_M02_P_STD_M02P_T3_OOR_LO_CHOICE (254u)
#define A123_M02_P_STD_M02P_T3_OOR_HI_CHOICE (255u)

#define A123_M02_P_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M02_P_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M02_P_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M02_P_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M02_P_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M02_P_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M02_P_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M02_P_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M02_P_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M02_P_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M02_P_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M02_P_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M02_P_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M02_P_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M02_P_XD1_M02P_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M02_P_XD1_M02P_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M02_P_XD1_M02P_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M02_P_XD1_M02P_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M02_P_XD1_M02P_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M02_P_XD1_M02P_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M02_P_XD1_M02P_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M02_P_XD1_M02P_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M02_P_XD2_M02P_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M02_P_XD2_M02P_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M02_P_XD2_M02P_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M02_P_XD2_M02P_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M02_P_XD2_M02P_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M02_P_XD2_M02P_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M02_P_XD2_M02P_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M02_P_XD2_M02P_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M03_N_STD_M03N_T0_OOR_LO_CHOICE (254u)
#define A123_M03_N_STD_M03N_T0_OOR_HI_CHOICE (255u)

#define A123_M03_N_STD_M03N_T1_OOR_LO_CHOICE (254u)
#define A123_M03_N_STD_M03N_T1_OOR_HI_CHOICE (255u)

#define A123_M03_N_STD_M03N_T2_OOR_LO_CHOICE (254u)
#define A123_M03_N_STD_M03N_T2_OOR_HI_CHOICE (255u)

#define A123_M03_N_STD_M03N_T3_OOR_LO_CHOICE (254u)
#define A123_M03_N_STD_M03N_T3_OOR_HI_CHOICE (255u)

#define A123_M03_N_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M03_N_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M03_N_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M03_N_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M03_N_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M03_N_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M03_N_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M03_N_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M03_N_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M03_N_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M03_N_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M03_N_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M03_N_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M03_N_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M03_N_XD1_M03N_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M03_N_XD1_M03N_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M03_N_XD1_M03N_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M03_N_XD1_M03N_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M03_N_XD1_M03N_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M03_N_XD1_M03N_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M03_N_XD1_M03N_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M03_N_XD1_M03N_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M03_N_XD2_M03N_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M03_N_XD2_M03N_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M03_N_XD2_M03N_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M03_N_XD2_M03N_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M03_N_XD2_M03N_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M03_N_XD2_M03N_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M03_N_XD2_M03N_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M03_N_XD2_M03N_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M04_P_STD_M04P_T0_OOR_LO_CHOICE (254u)
#define A123_M04_P_STD_M04P_T0_OOR_HI_CHOICE (255u)

#define A123_M04_P_STD_M04P_T1_OOR_LO_CHOICE (254u)
#define A123_M04_P_STD_M04P_T1_OOR_HI_CHOICE (255u)

#define A123_M04_P_STD_M04P_T2_OOR_LO_CHOICE (254u)
#define A123_M04_P_STD_M04P_T2_OOR_HI_CHOICE (255u)

#define A123_M04_P_STD_M04P_T3_OOR_LO_CHOICE (254u)
#define A123_M04_P_STD_M04P_T3_OOR_HI_CHOICE (255u)

#define A123_M04_P_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M04_P_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M04_P_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M04_P_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M04_P_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M04_P_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M04_P_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M04_P_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M04_P_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M04_P_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M04_P_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M04_P_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M04_P_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M04_P_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M04_P_XD1_M04P_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M04_P_XD1_M04P_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M04_P_XD1_M04P_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M04_P_XD1_M04P_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M04_P_XD1_M04P_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M04_P_XD1_M04P_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M04_P_XD1_M04P_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M04_P_XD1_M04P_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M04_P_XD2_M04P_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M04_P_XD2_M04P_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M04_P_XD2_M04P_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M04_P_XD2_M04P_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M04_P_XD2_M04P_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M04_P_XD2_M04P_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M04_P_XD2_M04P_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M04_P_XD2_M04P_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M05_N_STD_M05N_T0_OOR_LO_CHOICE (254u)
#define A123_M05_N_STD_M05N_T0_OOR_HI_CHOICE (255u)

#define A123_M05_N_STD_M05N_T1_OOR_LO_CHOICE (254u)
#define A123_M05_N_STD_M05N_T1_OOR_HI_CHOICE (255u)

#define A123_M05_N_STD_M05N_T2_OOR_LO_CHOICE (254u)
#define A123_M05_N_STD_M05N_T2_OOR_HI_CHOICE (255u)

#define A123_M05_N_STD_M05N_T3_OOR_LO_CHOICE (254u)
#define A123_M05_N_STD_M05N_T3_OOR_HI_CHOICE (255u)

#define A123_M05_N_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M05_N_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M05_N_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M05_N_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M05_N_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M05_N_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M05_N_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M05_N_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M05_N_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M05_N_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M05_N_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M05_N_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M05_N_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M05_N_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M05_N_XD1_M05N_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M05_N_XD1_M05N_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M05_N_XD1_M05N_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M05_N_XD1_M05N_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M05_N_XD1_M05N_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M05_N_XD1_M05N_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M05_N_XD1_M05N_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M05_N_XD1_M05N_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M05_N_XD2_M05N_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M05_N_XD2_M05N_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M05_N_XD2_M05N_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M05_N_XD2_M05N_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M05_N_XD2_M05N_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M05_N_XD2_M05N_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M05_N_XD2_M05N_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M05_N_XD2_M05N_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M06_P_STD_M06P_T0_OOR_LO_CHOICE (254u)
#define A123_M06_P_STD_M06P_T0_OOR_HI_CHOICE (255u)

#define A123_M06_P_STD_M06P_T1_OOR_LO_CHOICE (254u)
#define A123_M06_P_STD_M06P_T1_OOR_HI_CHOICE (255u)

#define A123_M06_P_STD_M06P_T2_OOR_LO_CHOICE (254u)
#define A123_M06_P_STD_M06P_T2_OOR_HI_CHOICE (255u)

#define A123_M06_P_STD_M06P_T3_OOR_LO_CHOICE (254u)
#define A123_M06_P_STD_M06P_T3_OOR_HI_CHOICE (255u)

#define A123_M06_P_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M06_P_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M06_P_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M06_P_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M06_P_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M06_P_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M06_P_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M06_P_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M06_P_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M06_P_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M06_P_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M06_P_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M06_P_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M06_P_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M06_P_XD1_M06P_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M06_P_XD1_M06P_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M06_P_XD1_M06P_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M06_P_XD1_M06P_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M06_P_XD1_M06P_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M06_P_XD1_M06P_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M06_P_XD1_M06P_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M06_P_XD1_M06P_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M06_P_XD2_M06P_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M06_P_XD2_M06P_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M06_P_XD2_M06P_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M06_P_XD2_M06P_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M06_P_XD2_M06P_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M06_P_XD2_M06P_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M06_P_XD2_M06P_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M06_P_XD2_M06P_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M07_N_STD_M07N_T0_OOR_LO_CHOICE (254u)
#define A123_M07_N_STD_M07N_T0_OOR_HI_CHOICE (255u)

#define A123_M07_N_STD_M07N_T1_OOR_LO_CHOICE (254u)
#define A123_M07_N_STD_M07N_T1_OOR_HI_CHOICE (255u)

#define A123_M07_N_STD_M07N_T2_OOR_LO_CHOICE (254u)
#define A123_M07_N_STD_M07N_T2_OOR_HI_CHOICE (255u)

#define A123_M07_N_STD_M07N_T3_OOR_LO_CHOICE (254u)
#define A123_M07_N_STD_M07N_T3_OOR_HI_CHOICE (255u)

#define A123_M07_N_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M07_N_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M07_N_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M07_N_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M07_N_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M07_N_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M07_N_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M07_N_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M07_N_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M07_N_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M07_N_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M07_N_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M07_N_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M07_N_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M07_N_XD1_M07N_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M07_N_XD1_M07N_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M07_N_XD1_M07N_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M07_N_XD1_M07N_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M07_N_XD1_M07N_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M07_N_XD1_M07N_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M07_N_XD1_M07N_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M07_N_XD1_M07N_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M07_N_XD2_M07N_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M07_N_XD2_M07N_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M07_N_XD2_M07N_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M07_N_XD2_M07N_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M07_N_XD2_M07N_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M07_N_XD2_M07N_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M07_N_XD2_M07N_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M07_N_XD2_M07N_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M08_P_STD_M08P_T0_OOR_LO_CHOICE (254u)
#define A123_M08_P_STD_M08P_T0_OOR_HI_CHOICE (255u)

#define A123_M08_P_STD_M08P_T1_OOR_LO_CHOICE (254u)
#define A123_M08_P_STD_M08P_T1_OOR_HI_CHOICE (255u)

#define A123_M08_P_STD_M08P_T2_OOR_LO_CHOICE (254u)
#define A123_M08_P_STD_M08P_T2_OOR_HI_CHOICE (255u)

#define A123_M08_P_STD_M08P_T3_OOR_LO_CHOICE (254u)
#define A123_M08_P_STD_M08P_T3_OOR_HI_CHOICE (255u)

#define A123_M08_P_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M08_P_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M08_P_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M08_P_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M08_P_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M08_P_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M08_P_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M08_P_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M08_P_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M08_P_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M08_P_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M08_P_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M08_P_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M08_P_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M08_P_XD1_M08P_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M08_P_XD1_M08P_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M08_P_XD1_M08P_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M08_P_XD1_M08P_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M08_P_XD1_M08P_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M08_P_XD1_M08P_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M08_P_XD1_M08P_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M08_P_XD1_M08P_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M08_P_XD2_M08P_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M08_P_XD2_M08P_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M08_P_XD2_M08P_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M08_P_XD2_M08P_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M08_P_XD2_M08P_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M08_P_XD2_M08P_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M08_P_XD2_M08P_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M08_P_XD2_M08P_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M09_N_STD_M09N_T0_OOR_LO_CHOICE (254u)
#define A123_M09_N_STD_M09N_T0_OOR_HI_CHOICE (255u)

#define A123_M09_N_STD_M09N_T1_OOR_LO_CHOICE (254u)
#define A123_M09_N_STD_M09N_T1_OOR_HI_CHOICE (255u)

#define A123_M09_N_STD_M09N_T2_OOR_LO_CHOICE (254u)
#define A123_M09_N_STD_M09N_T2_OOR_HI_CHOICE (255u)

#define A123_M09_N_STD_M09N_T3_OOR_LO_CHOICE (254u)
#define A123_M09_N_STD_M09N_T3_OOR_HI_CHOICE (255u)

#define A123_M09_N_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M09_N_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M09_N_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M09_N_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M09_N_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M09_N_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M09_N_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M09_N_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M09_N_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M09_N_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M09_N_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M09_N_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M09_N_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M09_N_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M09_N_XD1_M09N_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M09_N_XD1_M09N_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M09_N_XD1_M09N_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M09_N_XD1_M09N_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M09_N_XD1_M09N_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M09_N_XD1_M09N_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M09_N_XD1_M09N_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M09_N_XD1_M09N_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M09_N_XD2_M09N_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M09_N_XD2_M09N_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M09_N_XD2_M09N_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M09_N_XD2_M09N_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M09_N_XD2_M09N_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M09_N_XD2_M09N_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M09_N_XD2_M09N_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M09_N_XD2_M09N_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M10_P_STD_M10P_T0_OOR_LO_CHOICE (254u)
#define A123_M10_P_STD_M10P_T0_OOR_HI_CHOICE (255u)

#define A123_M10_P_STD_M10P_T1_OOR_LO_CHOICE (254u)
#define A123_M10_P_STD_M10P_T1_OOR_HI_CHOICE (255u)

#define A123_M10_P_STD_M10P_T2_OOR_LO_CHOICE (254u)
#define A123_M10_P_STD_M10P_T2_OOR_HI_CHOICE (255u)

#define A123_M10_P_STD_M10P_T3_OOR_LO_CHOICE (254u)
#define A123_M10_P_STD_M10P_T3_OOR_HI_CHOICE (255u)

#define A123_M10_P_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M10_P_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M10_P_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M10_P_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M10_P_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M10_P_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M10_P_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M10_P_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M10_P_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M10_P_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M10_P_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M10_P_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M10_P_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M10_P_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M10_P_XD1_M10P_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M10_P_XD1_M10P_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M10_P_XD1_M10P_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M10_P_XD1_M10P_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M10_P_XD1_M10P_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M10_P_XD1_M10P_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M10_P_XD1_M10P_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M10_P_XD1_M10P_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M10_P_XD2_M10P_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M10_P_XD2_M10P_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M10_P_XD2_M10P_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M10_P_XD2_M10P_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M10_P_XD2_M10P_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M10_P_XD2_M10P_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M10_P_XD2_M10P_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M10_P_XD2_M10P_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M11_N_STD_M11N_T0_OOR_LO_CHOICE (254u)
#define A123_M11_N_STD_M11N_T0_OOR_HI_CHOICE (255u)

#define A123_M11_N_STD_M11N_T1_OOR_LO_CHOICE (254u)
#define A123_M11_N_STD_M11N_T1_OOR_HI_CHOICE (255u)

#define A123_M11_N_STD_M11N_T2_OOR_LO_CHOICE (254u)
#define A123_M11_N_STD_M11N_T2_OOR_HI_CHOICE (255u)

#define A123_M11_N_STD_M11N_T3_OOR_LO_CHOICE (254u)
#define A123_M11_N_STD_M11N_T3_OOR_HI_CHOICE (255u)

#define A123_M11_N_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M11_N_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M11_N_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M11_N_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M11_N_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M11_N_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M11_N_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M11_N_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M11_N_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M11_N_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M11_N_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M11_N_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M11_N_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M11_N_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M11_N_XD1_M11N_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M11_N_XD1_M11N_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M11_N_XD1_M11N_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M11_N_XD1_M11N_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M11_N_XD1_M11N_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M11_N_XD1_M11N_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M11_N_XD1_M11N_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M11_N_XD1_M11N_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M11_N_XD2_M11N_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M11_N_XD2_M11N_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M11_N_XD2_M11N_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M11_N_XD2_M11N_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M11_N_XD2_M11N_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M11_N_XD2_M11N_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M11_N_XD2_M11N_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M11_N_XD2_M11N_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M12_P_STD_M12P_T0_OOR_LO_CHOICE (254u)
#define A123_M12_P_STD_M12P_T0_OOR_HI_CHOICE (255u)

#define A123_M12_P_STD_M12P_T1_OOR_LO_CHOICE (254u)
#define A123_M12_P_STD_M12P_T1_OOR_HI_CHOICE (255u)

#define A123_M12_P_STD_M12P_T2_OOR_LO_CHOICE (254u)
#define A123_M12_P_STD_M12P_T2_OOR_HI_CHOICE (255u)

#define A123_M12_P_STD_M12P_T3_OOR_LO_CHOICE (254u)
#define A123_M12_P_STD_M12P_T3_OOR_HI_CHOICE (255u)

#define A123_M12_P_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M12_P_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M12_P_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M12_P_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M12_P_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M12_P_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M12_P_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M12_P_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M12_P_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M12_P_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M12_P_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M12_P_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M12_P_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M12_P_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M12_P_XD1_M12P_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M12_P_XD1_M12P_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M12_P_XD1_M12P_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M12_P_XD1_M12P_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M12_P_XD1_M12P_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M12_P_XD1_M12P_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M12_P_XD1_M12P_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M12_P_XD1_M12P_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M12_P_XD2_M12P_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M12_P_XD2_M12P_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M12_P_XD2_M12P_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M12_P_XD2_M12P_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M12_P_XD2_M12P_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M12_P_XD2_M12P_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M12_P_XD2_M12P_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M12_P_XD2_M12P_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M13_N_STD_M13N_T0_OOR_LO_CHOICE (254u)
#define A123_M13_N_STD_M13N_T0_OOR_HI_CHOICE (255u)

#define A123_M13_N_STD_M13N_T1_OOR_LO_CHOICE (254u)
#define A123_M13_N_STD_M13N_T1_OOR_HI_CHOICE (255u)

#define A123_M13_N_STD_M13N_T2_OOR_LO_CHOICE (254u)
#define A123_M13_N_STD_M13N_T2_OOR_HI_CHOICE (255u)

#define A123_M13_N_STD_M13N_T3_OOR_LO_CHOICE (254u)
#define A123_M13_N_STD_M13N_T3_OOR_HI_CHOICE (255u)

#define A123_M13_N_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M13_N_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M13_N_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M13_N_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M13_N_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M13_N_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M13_N_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M13_N_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M13_N_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M13_N_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M13_N_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M13_N_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M13_N_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M13_N_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M13_N_XD1_M13N_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M13_N_XD1_M13N_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M13_N_XD1_M13N_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M13_N_XD1_M13N_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M13_N_XD1_M13N_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M13_N_XD1_M13N_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M13_N_XD1_M13N_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M13_N_XD1_M13N_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M13_N_XD2_M13N_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M13_N_XD2_M13N_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M13_N_XD2_M13N_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M13_N_XD2_M13N_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M13_N_XD2_M13N_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M13_N_XD2_M13N_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M13_N_XD2_M13N_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M13_N_XD2_M13N_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M14_P_STD_M14P_T0_OOR_LO_CHOICE (254u)
#define A123_M14_P_STD_M14P_T0_OOR_HI_CHOICE (255u)

#define A123_M14_P_STD_M14P_T1_OOR_LO_CHOICE (254u)
#define A123_M14_P_STD_M14P_T1_OOR_HI_CHOICE (255u)

#define A123_M14_P_STD_M14P_T2_OOR_LO_CHOICE (254u)
#define A123_M14_P_STD_M14P_T2_OOR_HI_CHOICE (255u)

#define A123_M14_P_STD_M14P_T3_OOR_LO_CHOICE (254u)
#define A123_M14_P_STD_M14P_T3_OOR_HI_CHOICE (255u)

#define A123_M14_P_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M14_P_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M14_P_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M14_P_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M14_P_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M14_P_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M14_P_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M14_P_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M14_P_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M14_P_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M14_P_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M14_P_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M14_P_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M14_P_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M14_P_XD1_M14P_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M14_P_XD1_M14P_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M14_P_XD1_M14P_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M14_P_XD1_M14P_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M14_P_XD1_M14P_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M14_P_XD1_M14P_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M14_P_XD1_M14P_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M14_P_XD1_M14P_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M14_P_XD2_M14P_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M14_P_XD2_M14P_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M14_P_XD2_M14P_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M14_P_XD2_M14P_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M14_P_XD2_M14P_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M14_P_XD2_M14P_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M14_P_XD2_M14P_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M14_P_XD2_M14P_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_M15_N_STD_M15N_T0_OOR_LO_CHOICE (254u)
#define A123_M15_N_STD_M15N_T0_OOR_HI_CHOICE (255u)

#define A123_M15_N_STD_M15N_T1_OOR_LO_CHOICE (254u)
#define A123_M15_N_STD_M15N_T1_OOR_HI_CHOICE (255u)

#define A123_M15_N_STD_M15N_T2_OOR_LO_CHOICE (254u)
#define A123_M15_N_STD_M15N_T2_OOR_HI_CHOICE (255u)

#define A123_M15_N_STD_M15N_T3_OOR_LO_CHOICE (254u)
#define A123_M15_N_STD_M15N_T3_OOR_HI_CHOICE (255u)

#define A123_M15_N_STD_MOD_V_MIN_NO_VALUE_CHOICE (8190u)
#define A123_M15_N_STD_MOD_V_MIN_ERROR_CHOICE (8191u)

#define A123_M15_N_STD_MOD_TMP_CHN_TEMPERATURE_0_CHOICE (0u)
#define A123_M15_N_STD_MOD_TMP_CHN_TEMPERATURE_1_CHOICE (1u)
#define A123_M15_N_STD_MOD_TMP_CHN_TEMPERATURE_2_CHOICE (2u)
#define A123_M15_N_STD_MOD_TMP_CHN_TEMPERATURE_3_CHOICE (3u)
#define A123_M15_N_STD_MOD_TMP_CHN_TEMPERATURE_4_CHOICE (4u)
#define A123_M15_N_STD_MOD_TMP_CHN_RESERVED_5_CHOICE (5u)
#define A123_M15_N_STD_MOD_TMP_CHN_RESERVED_6_CHOICE (6u)
#define A123_M15_N_STD_MOD_TMP_CHN_RESERVED_7_CHOICE (7u)

#define A123_M15_N_STD_MOD_V_MAX_NO_VALUE_CHOICE (8190u)
#define A123_M15_N_STD_MOD_V_MAX_ERROR_CHOICE (8191u)

#define A123_M15_N_STD_MOD_V_AVE_NO_VALUE_CHOICE (8190u)
#define A123_M15_N_STD_MOD_V_AVE_ERROR_CHOICE (8191u)

#define A123_M15_N_XD1_M15N_V_MBB_TOTAL_NO_VALUE_CHOICE (32766u)
#define A123_M15_N_XD1_M15N_V_MBB_TOTAL_ERROR_CHOICE (32767u)

#define A123_M15_N_XD1_M15N_V_CELL_01_NO_VALUE_CHOICE (16382u)
#define A123_M15_N_XD1_M15N_V_CELL_01_ERROR_CHOICE (16383u)

#define A123_M15_N_XD1_M15N_V_CELL_02_NO_VALUE_CHOICE (16382u)
#define A123_M15_N_XD1_M15N_V_CELL_02_ERROR_CHOICE (16383u)

#define A123_M15_N_XD1_M15N_V_CELL_03_NO_VALUE_CHOICE (16382u)
#define A123_M15_N_XD1_M15N_V_CELL_03_ERROR_CHOICE (16383u)

#define A123_M15_N_XD2_M15N_V_CELL_04_NO_VALUE_CHOICE (16382u)
#define A123_M15_N_XD2_M15N_V_CELL_04_ERROR_CHOICE (16383u)

#define A123_M15_N_XD2_M15N_V_CELL_05_NO_VALUE_CHOICE (16382u)
#define A123_M15_N_XD2_M15N_V_CELL_05_ERROR_CHOICE (16383u)

#define A123_M15_N_XD2_M15N_V_CELL_06_NO_VALUE_CHOICE (16382u)
#define A123_M15_N_XD2_M15N_V_CELL_06_ERROR_CHOICE (16383u)

#define A123_M15_N_XD2_M15N_V_CELL_07_NO_VALUE_CHOICE (16382u)
#define A123_M15_N_XD2_M15N_V_CELL_07_ERROR_CHOICE (16383u)

#define A123_BCM_CMD_BCM_REQUEST_TYPE_OLD_SUMMARY__DATA_CHOICE (0u)
#define A123_BCM_CMD_BCM_REQUEST_TYPE_OLD_SUMMARY____ALL__EXTRA_CHOICE (1u)
#define A123_BCM_CMD_BCM_REQUEST_TYPE_OLD_SUMMARY___1__EXTRA__PER__REQUEST_CHOICE (2u)
#define A123_BCM_CMD_BCM_REQUEST_TYPE_OLD_SUMMARY___2__EXTRA__PER__REQUEST_CHOICE (3u)

#define A123_BCM_CMD_BCM_V_BALANCE_TARGET_NO_VALUE_CHOICE (8190u)
#define A123_BCM_CMD_BCM_V_BALANCE_TARGET_ERROR_CHOICE (8191u)

#define A123_BCM_CMD_BCM_LEAKAGE_CMD_CSM_DISABLED_CHOICE (0u)
#define A123_BCM_CMD_BCM_LEAKAGE_CMD_CSM_ENABLE_CHOICE (1u)
#define A123_BCM_CMD_BCM_LEAKAGE_CMD_CSM_ENABLE_W___FAST__START__MODE_CHOICE (2u)
#define A123_BCM_CMD_BCM_LEAKAGE_CMD_CSM_ENABLE__SLOW__MODE_CHOICE (3u)
#define A123_BCM_CMD_BCM_LEAKAGE_CMD_CSM_ENABLE__HIGH__SIDE__RELAY_CHOICE (4u)
#define A123_BCM_CMD_BCM_LEAKAGE_CMD_CSM_ENABLE__LOW__SIDE__RELAY_CHOICE (5u)

#define A123_BCM_CMD_BCM_LEAKAGE_CMD_IDM_DISABLED_CHOICE (0u)
#define A123_BCM_CMD_BCM_LEAKAGE_CMD_IDM_ENABLE_CHOICE (1u)
#define A123_BCM_CMD_BCM_LEAKAGE_CMD_IDM_ENABLE_W___FAST__START__MODE_CHOICE (2u)
#define A123_BCM_CMD_BCM_LEAKAGE_CMD_IDM_ENABLE__SLOW__MODE_CHOICE (3u)
#define A123_BCM_CMD_BCM_LEAKAGE_CMD_IDM_ENABLE__HIGH__SIDE__RELAY_CHOICE (4u)
#define A123_BCM_CMD_BCM_LEAKAGE_CMD_IDM_ENABLE__LOW__SIDE__RELAY_CHOICE (5u)

#define A123_BCM_CMD_BCM_REQUEST_TYPE_NEW_SUMMARY__DATA_CHOICE (0u)
#define A123_BCM_CMD_BCM_REQUEST_TYPE_NEW_SUMMARY____ALL__EXTRA_CHOICE (1u)
#define A123_BCM_CMD_BCM_REQUEST_TYPE_NEW_SUMMARY___1__EXTRA__PER__REQUEST_CHOICE (2u)
#define A123_BCM_CMD_BCM_REQUEST_TYPE_NEW_SUMMARY___2__EXTRA__PER__REQUEST_CHOICE (3u)

#define A123_BCM_CMD_BCM_MESSAGE_FORMAT_V0__MBB__CLASSIC_CHOICE (0u)
#define A123_BCM_CMD_BCM_MESSAGE_FORMAT_V1___CELL__ADDRESSABLE__BALANCE_CHOICE (1u)
#define A123_BCM_CMD_BCM_MESSAGE_FORMAT_RESERVED_2_CHOICE (2u)
#define A123_BCM_CMD_BCM_MESSAGE_FORMAT_RESERVED_3_CHOICE (3u)
#define A123_BCM_CMD_BCM_MESSAGE_FORMAT_RESERVED_4_CHOICE (4u)
#define A123_BCM_CMD_BCM_MESSAGE_FORMAT_RESERVED_5_CHOICE (5u)
#define A123_BCM_CMD_BCM_MESSAGE_FORMAT_RESERVED_6_CHOICE (6u)
#define A123_BCM_CMD_BCM_MESSAGE_FORMAT_RESERVED_7_CHOICE (7u)

#define A123_BCM_CMD_BCM_M01N_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M01N_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M02P_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M02P_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M03N_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M03N_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M04P_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M04P_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M05N_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M05N_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M06P_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M06P_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M07N_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M07N_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M08P_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M08P_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M09N_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M09N_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M10P_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M10P_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M11N_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M11N_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M12P_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M12P_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M13N_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M13N_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M14P_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M14P_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_M15N_BAL_POWER_LEVEL_NO_VALUE_CHOICE (14u)
#define A123_BCM_CMD_BCM_M15N_BAL_POWER_LEVEL_ERROR_CHOICE (15u)

#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_01___CELLS_1___15_CHOICE (0u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_02___CELLS_1___15_CHOICE (1u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_03___CELLS_1___15_CHOICE (2u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_04___CELLS_1___15_CHOICE (3u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_05___CELLS_1___15_CHOICE (4u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_06___CELLS_1___15_CHOICE (5u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_07___CELLS_1___15_CHOICE (6u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_08___CELLS_1___15_CHOICE (7u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_09___CELLS_1___15_CHOICE (8u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_10___CELLS_1___15_CHOICE (9u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_11___CELLS_1___15_CHOICE (10u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_12___CELLS_1___15_CHOICE (11u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_13___CELLS_1__15_CHOICE (12u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_14___CELLS_1___15_CHOICE (13u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_15___CELLS_1___15_CHOICE (14u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_16___CELLS_1___15_CHOICE (15u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_17___CELLS_1___15_CHOICE (16u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_18___CELLS_1___15_CHOICE (17u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_19___CELLS_1___15_CHOICE (18u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_20___CELLS_1___15_CHOICE (19u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_21___CELLS_1___15_CHOICE (20u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_22___CELLS_1___15_CHOICE (21u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_23___CELLS_1___15_CHOICE (22u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_24___CELLS_1___15_CHOICE (23u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_01___CELLS_16___30_CHOICE (128u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_02___CELLS_16___30_CHOICE (129u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_03___CELLS_16___30_CHOICE (130u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_04___CELLS_16___30_CHOICE (131u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_05___CELLS_16___30_CHOICE (132u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_06___CELLS_16___30_CHOICE (133u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_07___CELLS_16___30_CHOICE (134u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_08___CELLS_16___30_CHOICE (135u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_09___CELLS_16___30_CHOICE (136u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_10___CELLS_16___30_CHOICE (137u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_11___CELLS_16___30_CHOICE (138u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_12___CELLS_16___30_CHOICE (139u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_13___CELLS_16___30_CHOICE (140u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_14___CELLS_16___30_CHOICE (141u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_15___CELLS_16___30_CHOICE (142u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_16___CELLS_16___30_CHOICE (143u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_17___CELLS_16___30_CHOICE (144u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_18___CELLS_16___30_CHOICE (145u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_19___CELLS_16___30_CHOICE (146u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_20___CELLS_16___30_CHOICE (147u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_21___CELLS_16___30_CHOICE (148u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_22___CELLS_16___30_CHOICE (149u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_23___CELLS_16___30_CHOICE (150u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_MBB_24___CELLS_16___30_CHOICE (151u)
#define A123_BCM_CMD_BCM_BALANCE_CMD_TARGET_NO_VALUE_CHOICE (255u)

#define A123_BCM_DIAG_REQ_DIAG_SID_READ_DATA_BY_IDENTIFIER_CHOICE (34u)
#define A123_BCM_DIAG_REQ_DIAG_SID_WRITE_DATA_BY_IDENTIFIER_CHOICE (46u)
#define A123_BCM_DIAG_REQ_DIAG_SID_READ_DATA_BY_IDENTIFIER__POS_RSP_CHOICE (98u)
#define A123_BCM_DIAG_REQ_DIAG_SID_WRITE_DATA_BY_IDENTIFIER__POS_RSP_CHOICE (110u)
#define A123_BCM_DIAG_REQ_DIAG_SID_NEGATIVE_RESPONSE_CHOICE (127u)

#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_BPWR_MEAS_CHOICE (57392u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_14_V_PWR_MEAS_CHOICE (57393u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_LEM_HI_RANGE_CHOICE (57394u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_LEM_LO_RANGE_CHOICE (57395u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_COOL_TEMP_CHOICE (57396u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_CTR1_MON_CHOICE (57397u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_CTR2_MON_CHOICE (57398u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_CTR4_MON_CHOICE (57399u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_CTR5_MON_CHOICE (57400u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_CTR6_MON_CHOICE (57401u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_CTR7_MON_CHOICE (57402u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_CTR_CUR_CHOICE (57403u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_VALVE_FB_CHOICE (57404u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_WATER2_DET_CHOICE (57405u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_WATER1_DET_CHOICE (57406u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_HPWR_MEAS_CHOICE (57407u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_AI_A_CHOICE (57408u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_PROX_DET_CHOICE (57409u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_5_V_PWR_MEAS_CHOICE (57410u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_AIN_RLY_PWR_MEAS_CHOICE (57411u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ICM_FGD1_CHOICE (57425u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ICM_FGD2_CHOICE (57426u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ICM_PILOT_PWM_CHOICE (57427u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ICM_MOD_FAULT_CHOICE (57428u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ICM_LOCK_MON_CHOICE (57429u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ICM_PWM_A_MON_CHOICE (57436u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ICM_PWM_B_MON_CHOICE (57437u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ICM_PWM_C_MON_CHOICE (57438u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ICM_PWM_D_MON_CHOICE (57439u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_0__TIME_CHOICE (60160u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_1__TIME_CHOICE (60161u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_2__TIME_CHOICE (60162u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_3__TIME_CHOICE (60163u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_4__TIME_CHOICE (60164u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_5__TIME_CHOICE (60165u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_6__TIME_CHOICE (60166u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_7__TIME_CHOICE (60167u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_8__TIME_CHOICE (60168u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_9__TIME_CHOICE (60169u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_10__TIME_CHOICE (60170u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_11__TIME_CHOICE (60171u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_12__TIME_CHOICE (60172u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_13__TIME_CHOICE (60173u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_14__TIME_CHOICE (60174u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_15__TIME_CHOICE (60175u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_16__TIME_CHOICE (60176u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_17__TIME_CHOICE (60177u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_18__TIME_CHOICE (60178u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_19__TIME_CHOICE (60179u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_20__TIME_CHOICE (60180u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_21__TIME_CHOICE (60181u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_22__TIME_CHOICE (60182u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BACKGROUND__TASK_23__TIME_CHOICE (60183u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_FOREGROUND__TASK_A__TIME_CHOICE (61184u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_FOREGROUND__TASK_B__TIME_CHOICE (61185u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_FOREGROUND__TASK_C__TIME_CHOICE (61186u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_FOREGROUND__TASK_D__TIME_CHOICE (61187u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_FOREGROUND__TASK_E__TIME_CHOICE (61188u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_STATE__OF__CHARGE_CHOICE (61456u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_HYSTERESIS__STATE_CHOICE (61457u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ENERGY__THROUGHPUT_CHOICE (61458u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_CALENDAR__LIFE____TIME_CHOICE (61459u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_CALENDAR__LIFE____CAPACITY__FADE_CHOICE (61460u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_CALENDAR__LIFE____IMPEDANCE__GROWTH_CHOICE (61461u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_CYCLE__LIFE____TIME_CHOICE (61462u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_CYCLE__LIFE____CAPACITY__FADE_CHOICE (61463u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_CYCLE__LIFE____IMPEDANCE__GROWTH_CHOICE (61464u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_BOOT_SW_IDENTIFICATION_CHOICE (61824u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_APP_SW_IDENTIFICATION_CHOICE (61825u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_ECU_SERIAL_NUMBER_CHOICE (61836u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_SYS_SUPPLIER_ECU_HW_NUMBER_CHOICE (61842u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_DIAG_DATA_MESSAGE_MASK_CHOICE (65008u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_LEAKAGE__MEASUREMENT_CHOICE (65025u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_0_CHOICE (65280u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_1_CHOICE (65281u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_2_CHOICE (65282u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_3_CHOICE (65283u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_4_CHOICE (65284u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_5_CHOICE (65285u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_6_CHOICE (65286u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_7_CHOICE (65287u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_8_CHOICE (65288u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_9_CHOICE (65289u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_10_CHOICE (65290u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_11_CHOICE (65291u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_12_CHOICE (65292u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_13_CHOICE (65293u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_14_CHOICE (65294u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_15_CHOICE (65295u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_16_CHOICE (65296u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_17_CHOICE (65297u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_18_CHOICE (65298u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_19_CHOICE (65299u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_20_CHOICE (65300u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_21_CHOICE (65301u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_22_CHOICE (65302u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_23_CHOICE (65303u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_24_CHOICE (65304u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_25_CHOICE (65305u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_26_CHOICE (65306u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_27_CHOICE (65307u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_28_CHOICE (65308u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_29_CHOICE (65309u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_30_CHOICE (65310u)
#define A123_BCM_DIAG_REQ_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_31_CHOICE (65311u)

#define A123_BCM_DIAG_RSP_DIAG_SID_READ_DATA_BY_IDENTIFIER_CHOICE (34u)
#define A123_BCM_DIAG_RSP_DIAG_SID_WRITE_DATA_BY_IDENTIFIER_CHOICE (46u)
#define A123_BCM_DIAG_RSP_DIAG_SID_READ_DATA_BY_IDENTIFIER__POS_RSP_CHOICE (98u)
#define A123_BCM_DIAG_RSP_DIAG_SID_WRITE_DATA_BY_IDENTIFIER__POS_RSP_CHOICE (110u)
#define A123_BCM_DIAG_RSP_DIAG_SID_NEGATIVE_RESPONSE_CHOICE (127u)

#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_BPWR_MEAS_CHOICE (57392u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_14_V_PWR_MEAS_CHOICE (57393u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_LEM_HI_RANGE_CHOICE (57394u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_LEM_LO_RANGE_CHOICE (57395u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_COOL_TEMP_CHOICE (57396u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_CTR1_MON_CHOICE (57397u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_CTR2_MON_CHOICE (57398u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_CTR4_MON_CHOICE (57399u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_CTR5_MON_CHOICE (57400u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_CTR6_MON_CHOICE (57401u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_CTR7_MON_CHOICE (57402u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_CTR_CUR_CHOICE (57403u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_VALVE_FB_CHOICE (57404u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_WATER2_DET_CHOICE (57405u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_WATER1_DET_CHOICE (57406u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_HPWR_MEAS_CHOICE (57407u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_AI_A_CHOICE (57408u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_PROX_DET_CHOICE (57409u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_5_V_PWR_MEAS_CHOICE (57410u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_AIN_RLY_PWR_MEAS_CHOICE (57411u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ICM_FGD1_CHOICE (57425u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ICM_FGD2_CHOICE (57426u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ICM_PILOT_PWM_CHOICE (57427u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ICM_MOD_FAULT_CHOICE (57428u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ICM_LOCK_MON_CHOICE (57429u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ICM_PWM_A_MON_CHOICE (57436u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ICM_PWM_B_MON_CHOICE (57437u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ICM_PWM_C_MON_CHOICE (57438u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ICM_PWM_D_MON_CHOICE (57439u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_0__TIME_CHOICE (60160u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_1__TIME_CHOICE (60161u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_2__TIME_CHOICE (60162u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_3__TIME_CHOICE (60163u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_4__TIME_CHOICE (60164u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_5__TIME_CHOICE (60165u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_6__TIME_CHOICE (60166u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_7__TIME_CHOICE (60167u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_8__TIME_CHOICE (60168u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_9__TIME_CHOICE (60169u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_10__TIME_CHOICE (60170u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_11__TIME_CHOICE (60171u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_12__TIME_CHOICE (60172u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_13__TIME_CHOICE (60173u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_14__TIME_CHOICE (60174u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_15__TIME_CHOICE (60175u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_16__TIME_CHOICE (60176u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_17__TIME_CHOICE (60177u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_18__TIME_CHOICE (60178u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_19__TIME_CHOICE (60179u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_20__TIME_CHOICE (60180u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_21__TIME_CHOICE (60181u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_22__TIME_CHOICE (60182u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BACKGROUND__TASK_23__TIME_CHOICE (60183u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_FOREGROUND__TASK_A__TIME_CHOICE (61184u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_FOREGROUND__TASK_B__TIME_CHOICE (61185u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_FOREGROUND__TASK_C__TIME_CHOICE (61186u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_FOREGROUND__TASK_D__TIME_CHOICE (61187u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_FOREGROUND__TASK_E__TIME_CHOICE (61188u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_STATE__OF__CHARGE_CHOICE (61456u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_HYSTERESIS__STATE_CHOICE (61457u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ENERGY__THROUGHPUT_CHOICE (61458u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_CALENDAR__LIFE____TIME_CHOICE (61459u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_CALENDAR__LIFE____CAPACITY__FADE_CHOICE (61460u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_CALENDAR__LIFE____IMPEDANCE__GROWTH_CHOICE (61461u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_CYCLE__LIFE____TIME_CHOICE (61462u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_CYCLE__LIFE____CAPACITY__FADE_CHOICE (61463u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_CYCLE__LIFE____IMPEDANCE__GROWTH_CHOICE (61464u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_BOOT_SW_IDENTIFICATION_CHOICE (61824u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_APP_SW_IDENTIFICATION_CHOICE (61825u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_ECU_SERIAL_NUMBER_CHOICE (61836u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_SYS_SUPPLIER_ECU_HW_NUMBER_CHOICE (61842u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_DIAG_DATA_MESSAGE_MASK_CHOICE (65008u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_LEAKAGE__MEASUREMENT_CHOICE (65025u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_0_CHOICE (65280u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_1_CHOICE (65281u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_2_CHOICE (65282u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_3_CHOICE (65283u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_4_CHOICE (65284u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_5_CHOICE (65285u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_6_CHOICE (65286u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_7_CHOICE (65287u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_8_CHOICE (65288u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_9_CHOICE (65289u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_10_CHOICE (65290u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_11_CHOICE (65291u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_12_CHOICE (65292u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_13_CHOICE (65293u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_14_CHOICE (65294u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_15_CHOICE (65295u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_16_CHOICE (65296u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_17_CHOICE (65297u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_18_CHOICE (65298u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_19_CHOICE (65299u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_20_CHOICE (65300u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_21_CHOICE (65301u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_22_CHOICE (65302u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_23_CHOICE (65303u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_24_CHOICE (65304u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_25_CHOICE (65305u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_26_CHOICE (65306u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_27_CHOICE (65307u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_28_CHOICE (65308u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_29_CHOICE (65309u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_30_CHOICE (65310u)
#define A123_BCM_DIAG_RSP_DIAG_DID_BCM_NVM__SCRATCHPAD__DATA__BYTE_31_CHOICE (65311u)

/**
 * Signals in message M01N_STD.
 *
 * Standard data message 01.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m01_n_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m01n_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m01n_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m01n_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m01n_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M01N_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m01_n_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m01n_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m01n_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m01n_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m01n_v_cell_03;
};

/**
 * Signals in message M01N_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m01_n_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m01n_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m01n_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m01n_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m01n_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m01n_v_cell_07;
};

/**
 * Signals in message M02P_STD.
 *
 * Standard data message 02.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m02_p_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m02p_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m02p_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m02p_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m02p_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M02P_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m02_p_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m02p_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m02p_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m02p_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m02p_v_cell_03;
};

/**
 * Signals in message M02P_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m02_p_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m02p_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m02p_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m02p_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m02p_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m02p_v_cell_07;
};

/**
 * Signals in message M03N_STD.
 *
 * Standard data message 03.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m03_n_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m03n_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m03n_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m03n_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m03n_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M03N_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m03_n_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m03n_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m03n_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m03n_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m03n_v_cell_03;
};

/**
 * Signals in message M03N_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m03_n_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m03n_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m03n_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m03n_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m03n_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m03n_v_cell_07;
};

/**
 * Signals in message M04P_STD.
 *
 * Standard data message 04.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m04_p_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m04p_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m04p_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m04p_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m04p_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M04P_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m04_p_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m04p_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m04p_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m04p_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m04p_v_cell_03;
};

/**
 * Signals in message M04P_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m04_p_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m04p_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m04p_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m04p_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m04p_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m04p_v_cell_07;
};

/**
 * Signals in message M05N_STD.
 *
 * Standard data message 05.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m05_n_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m05n_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m05n_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m05n_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m05n_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M05N_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m05_n_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m05n_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m05n_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m05n_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m05n_v_cell_03;
};

/**
 * Signals in message M05N_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m05_n_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m05n_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m05n_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m05n_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m05n_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m05n_v_cell_07;
};

/**
 * Signals in message M06P_STD.
 *
 * Standard data message 06.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m06_p_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m06p_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m06p_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m06p_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m06p_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M06P_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m06_p_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m06p_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m06p_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m06p_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m06p_v_cell_03;
};

/**
 * Signals in message M06P_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m06_p_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m06p_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m06p_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m06p_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m06p_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m06p_v_cell_07;
};

/**
 * Signals in message M07N_STD.
 *
 * Standard data message 07.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m07_n_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m07n_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m07n_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m07n_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m07n_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M07N_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m07_n_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m07n_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m07n_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m07n_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m07n_v_cell_03;
};

/**
 * Signals in message M07N_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m07_n_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m07n_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m07n_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m07n_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m07n_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m07n_v_cell_07;
};

/**
 * Signals in message M08P_STD.
 *
 * Standard data message 08.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m08_p_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m08p_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m08p_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m08p_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m08p_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M08P_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m08_p_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m08p_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m08p_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m08p_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m08p_v_cell_03;
};

/**
 * Signals in message M08P_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m08_p_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m08p_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m08p_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m08p_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m08p_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m08p_v_cell_07;
};

/**
 * Signals in message M09N_STD.
 *
 * Standard data message 09.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m09_n_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m09n_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m09n_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m09n_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m09n_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M09N_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m09_n_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m09n_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m09n_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m09n_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m09n_v_cell_03;
};

/**
 * Signals in message M09N_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m09_n_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m09n_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m09n_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m09n_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m09n_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m09n_v_cell_07;
};

/**
 * Signals in message M10P_STD.
 *
 * Standard data message 10.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m10_p_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m10p_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m10p_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m10p_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m10p_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M10P_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m10_p_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m10p_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m10p_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m10p_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m10p_v_cell_03;
};

/**
 * Signals in message M10P_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m10_p_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m10p_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m10p_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m10p_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m10p_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m10p_v_cell_07;
};

/**
 * Signals in message M11N_STD.
 *
 * Standard data message 11.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m11_n_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m11n_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m11n_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m11n_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m11n_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M11N_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m11_n_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m11n_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m11n_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m11n_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m11n_v_cell_03;
};

/**
 * Signals in message M11N_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m11_n_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m11n_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m11n_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m11n_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m11n_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m11n_v_cell_07;
};

/**
 * Signals in message M12P_STD.
 *
 * Standard data message 12.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m12_p_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m12p_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m12p_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m12p_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m12p_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M12P_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m12_p_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m12p_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m12p_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m12p_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m12p_v_cell_03;
};

/**
 * Signals in message M12P_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m12_p_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m12p_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m12p_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m12p_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m12p_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m12p_v_cell_07;
};

/**
 * Signals in message M13N_STD.
 *
 * Standard data message 13.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m13_n_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m13n_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m13n_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m13n_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m13n_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M13N_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m13_n_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m13n_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m13n_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m13n_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m13n_v_cell_03;
};

/**
 * Signals in message M13N_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m13_n_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m13n_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m13n_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m13n_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m13n_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m13n_v_cell_07;
};

/**
 * Signals in message M14P_STD.
 *
 * Standard data message 14.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m14_p_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m14p_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m14p_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m14p_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m14p_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M14P_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m14_p_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m14p_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m14p_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m14p_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m14p_v_cell_03;
};

/**
 * Signals in message M14P_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m14_p_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m14p_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m14p_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m14p_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m14p_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m14p_v_cell_07;
};

/**
 * Signals in message M15N_STD.
 *
 * Standard data message 15.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m15_n_std_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_response_id_std;

    /**
     * Standard data message multiplexor..
     *
     * Range: 0..15 (0..15 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_mux_chn;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m15n_t0;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m15n_t1;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m15n_t2;

    /**
     * Temperature sensor.
     *
     * Range: 0..255 (-40..87.5 Deg C)
     * Scale: 0.5
     * Offset: -40
     */
    uint8_t m15n_t3;

    /**
     * MBB woke up but received no command message this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_no_can;

    /**
     * Number of cells with balance enabled.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_bal_count;

    /**
     * Number of cells monitored by this MBB.
     *
     * Range: 0..255 (0..255 Cells)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_cell_count;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_sw_ver_major;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_sw_ver_minor;

    /**
     * MBB SW major version.
     *
     * Range: 0..255 (0..255 SW Version)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_sw_ver_build;

    /**
     * MBB woke up but received no command message and detected cell overvoltage in hardware this/last on cycle.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_no_can_overvolt;

    /**
     * Module voltage does not agree with sum of cell voltages within CAL.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_v_compare;

    /**
     * Voltage reference drift error detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_v_ref_drift;

    /**
     * Cell overvoltage detected in hardware.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_overvoltage_fault;

    /**
     * Cell overvoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_cell_overvolt;

    /**
     * Random access memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_ram_check;

    /**
     * Cell undervoltage detected in software.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_cell_undervolt;

    /**
     * Program memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_rom_check;

    /**
     * Module undervoltage detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_mod_undervolt;

    /**
     * Non-volatile memory check failed.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_err_nvm_check;

    /**
     * Module minimum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_min;

    /**
     * Module temperature multiplexor, clipped version of mux_chn for backwards compatability.
     *
     * Range: 0..7 (0..7 channel)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mod_tmp_chn;

    /**
     * Module maximum cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_max;

    /**
     * Module fault output line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_fault_out;

    /**
     * Module fault input line.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_fault_in;

    /**
     * One or more error conditions detected.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_error_flag;

    /**
     * Module average cell voltage.
     *
     * Range: 0..8000 (1..5 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t mod_v_ave;
};

/**
 * Signals in message M15N_XD1.
 *
 * Extra data message 1.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m15_n_xd1_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_response_id_xd1;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_bal_cell_03;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_bal_cell_02;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_bal_cell_01;

    /**
     * MBB total voltage.
     *
     * Range: 0..10000 (6..86 Volts)
     * Scale: 0.008
     * Offset: 6
     */
    uint16_t m15n_v_mbb_total;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m15n_v_cell_01;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m15n_v_cell_02;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m15n_v_cell_03;
};

/**
 * Signals in message M15N_XD2.
 *
 * Extra data message 2.  Measurements taken when BCM_CMD:bcm_request_type is not 0x0.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_m15_n_xd2_t {
    /**
     * Response index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_response_id_xd2;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_bal_cell_07;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_bal_cell_06;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_bal_cell_05;

    /**
     * Cell balancing response.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t m15n_bal_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m15n_v_cell_04;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m15n_v_cell_05;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m15n_v_cell_06;

    /**
     * Cell voltage.
     *
     * Range: 0..16380 (0..4.095 Volts)
     * Scale: 0.00025
     * Offset: 0
     */
    uint16_t m15n_v_cell_07;
};

/**
 * Signals in message BCM_CMD.
 *
 * BCM measurement request.BCM diagnostic request.BCM diagnostic response.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_bcm_cmd_t {
    /**
     * Request index.
     *
     * Range: 0..15 (0..15 index)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_request_id;

    /**
     * Requste type (standard/all data)
     *
     * Range: 0..3 (0..3 mode)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_request_type_old;

    /**
     * Target voltage for module cell balancing.
     *
     * Range: 0..6200 (1..4.1 Volts)
     * Scale: 0.0005
     * Offset: 1
     */
    uint16_t bcm_v_balance_target;

    /**
     * Leakage measurement mode command.
     *
     * Range: 0..7 (0..7 mode)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_leakage_cmd_csm;

    /**
     * Leakage measurement mode command.
     *
     * Range: 0..7 (0..7 mode)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_leakage_cmd_idm;

    /**
     * Requste type (standard/all data)
     *
     * Range: 0..3 (0..3 mode)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_request_type_new;

    /**
     * Message format definition to determine how 0x50 message should be interpreted and how MBBs should respond.
     *
     * Range: 0..15 (0..15 mode)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_message_format;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m01n_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m02p_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m03n_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m04p_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m05n_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m06p_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m07n_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m08p_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m09n_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m10p_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m11n_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m12p_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m13n_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m14p_bal_power_level;

    /**
     * Cell balance power level (active balance system).
     *
     * Range: 0..8 (0..100 %)
     * Scale: 12.5
     * Offset: 0
     */
    uint8_t bcm_m15n_bal_power_level;

    /**
     * Address of MBB to receive this set of balance commands.
     *
     * Range: 0..250 (0..250 MBB address)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_balance_cmd_target;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m01n_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m02p_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m03n_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m04p_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m05n_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m06p_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m07n_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m08p_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m09n_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m10p_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m11n_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m12p_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m13n_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m14p_bal_diag_mode;

    /**
     * Command to leave balance enabled during measurement for diagnostic purposes.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m15n_bal_diag_mode;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m01n_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m02p_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m03n_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m04p_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m05n_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m06p_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m07n_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m08p_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m09n_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m10p_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m11n_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m12p_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m13n_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m14p_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m15n_bal_ena_cell_07;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m01n_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m02p_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m03n_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m04p_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m05n_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m06p_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m07n_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m08p_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m09n_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m10p_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m11n_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m12p_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m13n_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m14p_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m15n_bal_ena_cell_06;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m01n_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m02p_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m03n_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m04p_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m05n_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m06p_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m07n_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m08p_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m09n_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m10p_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m11n_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m12p_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m13n_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m14p_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m15n_bal_ena_cell_05;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m01n_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m02p_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m03n_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m04p_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m05n_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m06p_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m07n_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m08p_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m09n_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m10p_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m11n_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m12p_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m13n_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m14p_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m15n_bal_ena_cell_04;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m01n_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m02p_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m03n_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m04p_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m05n_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m06p_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m07n_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m08p_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m09n_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m10p_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m11n_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m12p_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m13n_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m14p_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m15n_bal_ena_cell_03;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m01n_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m02p_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m03n_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m04p_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m05n_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m06p_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m07n_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m08p_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m09n_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m10p_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m11n_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m12p_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m13n_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m14p_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m15n_bal_ena_cell_02;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m01n_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m02p_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m03n_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m04p_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m05n_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m06p_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m07n_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m08p_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m09n_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m10p_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m11n_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m12p_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m13n_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m14p_bal_ena_cell_01;

    /**
     * Cell balancing command.
     *
     * Range: 0..1 (0..1 flag)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bcm_m15n_bal_ena_cell_01;
};

/**
 * Signals in message BCM_DIAG_REQ.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_bcm_diag_req_t {
    /**
     * ISO14229: Data length
     *
     * Range: 0..255 (0..255 bytes)
     * Scale: 1
     * Offset: 0
     */
    uint8_t diag_length;

    /**
     * ISO14229: Service Identifier
     *
     * Range: 0..255 (0..255 ServiceIdentifier)
     * Scale: 1
     * Offset: 0
     */
    uint8_t diag_sid;

    /**
     * ISO14229: Data Identifier
     *
     * Range: 0..65535 (0..65535 DataIdentifier)
     * Scale: 1
     * Offset: 0
     */
    uint16_t diag_did_bcm;

    /**
     * ISO14229: DID specific
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float diag_float;
};

/**
 * Signals in message BCM_DIAG_RSP.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_bcm_diag_rsp_t {
    /**
     * ISO14229: Data length
     *
     * Range: 0..255 (0..255 bytes)
     * Scale: 1
     * Offset: 0
     */
    uint8_t diag_length;

    /**
     * ISO14229: Service Identifier
     *
     * Range: 0..255 (0..255 ServiceIdentifier)
     * Scale: 1
     * Offset: 0
     */
    uint8_t diag_sid;

    /**
     * ISO14229: Data Identifier
     *
     * Range: 0..65535 (0..65535 DataIdentifier)
     * Scale: 1
     * Offset: 0
     */
    uint16_t diag_did_bcm;

    /**
     * ISO14229: DID specific
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float diag_float;
};

/**
 * Signals in message BCM_IDENTIFY_POR.
 *
 * All signal values are as on the CAN bus.
 */
struct A123_bcm_identify_por_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Pack message M01N_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m01_n_std_pack(
    uint8_t *dst_p,
    const struct A123_m01_n_std_t *src_p,
    size_t size);

/**
 * Unpack message M01N_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m01_n_std_unpack(
    struct A123_m01_n_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_std_m01n_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_m01n_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_m01n_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M01N_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m01_n_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m01_n_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M01N_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m01_n_xd1_unpack(
    struct A123_m01_n_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_xd1_m01n_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd1_m01n_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd1_m01n_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_xd1_m01n_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd1_m01n_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd1_m01n_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_xd1_m01n_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd1_m01n_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd1_m01n_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_xd1_m01n_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd1_m01n_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd1_m01n_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_xd1_m01n_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd1_m01n_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd1_m01n_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_xd1_m01n_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd1_m01n_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd1_m01n_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_xd1_m01n_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd1_m01n_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd1_m01n_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_xd1_m01n_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd1_m01n_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd1_m01n_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M01N_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m01_n_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m01_n_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M01N_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m01_n_xd2_unpack(
    struct A123_m01_n_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_xd2_m01n_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd2_m01n_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd2_m01n_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_xd2_m01n_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd2_m01n_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd2_m01n_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_xd2_m01n_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd2_m01n_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd2_m01n_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_xd2_m01n_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd2_m01n_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd2_m01n_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m01_n_xd2_m01n_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd2_m01n_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd2_m01n_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_xd2_m01n_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd2_m01n_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd2_m01n_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_xd2_m01n_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd2_m01n_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd2_m01n_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_xd2_m01n_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd2_m01n_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd2_m01n_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m01_n_xd2_m01n_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m01_n_xd2_m01n_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m01_n_xd2_m01n_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M02P_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m02_p_std_pack(
    uint8_t *dst_p,
    const struct A123_m02_p_std_t *src_p,
    size_t size);

/**
 * Unpack message M02P_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m02_p_std_unpack(
    struct A123_m02_p_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_std_m02p_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_m02p_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_m02p_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M02P_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m02_p_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m02_p_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M02P_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m02_p_xd1_unpack(
    struct A123_m02_p_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_xd1_m02p_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd1_m02p_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd1_m02p_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_xd1_m02p_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd1_m02p_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd1_m02p_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_xd1_m02p_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd1_m02p_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd1_m02p_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_xd1_m02p_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd1_m02p_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd1_m02p_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_xd1_m02p_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd1_m02p_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd1_m02p_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_xd1_m02p_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd1_m02p_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd1_m02p_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_xd1_m02p_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd1_m02p_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd1_m02p_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_xd1_m02p_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd1_m02p_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd1_m02p_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M02P_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m02_p_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m02_p_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M02P_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m02_p_xd2_unpack(
    struct A123_m02_p_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_xd2_m02p_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd2_m02p_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd2_m02p_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_xd2_m02p_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd2_m02p_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd2_m02p_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_xd2_m02p_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd2_m02p_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd2_m02p_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_xd2_m02p_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd2_m02p_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd2_m02p_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m02_p_xd2_m02p_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd2_m02p_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd2_m02p_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_xd2_m02p_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd2_m02p_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd2_m02p_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_xd2_m02p_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd2_m02p_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd2_m02p_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_xd2_m02p_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd2_m02p_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd2_m02p_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m02_p_xd2_m02p_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m02_p_xd2_m02p_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m02_p_xd2_m02p_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M03N_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m03_n_std_pack(
    uint8_t *dst_p,
    const struct A123_m03_n_std_t *src_p,
    size_t size);

/**
 * Unpack message M03N_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m03_n_std_unpack(
    struct A123_m03_n_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_std_m03n_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_m03n_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_m03n_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M03N_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m03_n_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m03_n_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M03N_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m03_n_xd1_unpack(
    struct A123_m03_n_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_xd1_m03n_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd1_m03n_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd1_m03n_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_xd1_m03n_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd1_m03n_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd1_m03n_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_xd1_m03n_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd1_m03n_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd1_m03n_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_xd1_m03n_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd1_m03n_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd1_m03n_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_xd1_m03n_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd1_m03n_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd1_m03n_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_xd1_m03n_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd1_m03n_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd1_m03n_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_xd1_m03n_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd1_m03n_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd1_m03n_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_xd1_m03n_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd1_m03n_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd1_m03n_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M03N_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m03_n_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m03_n_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M03N_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m03_n_xd2_unpack(
    struct A123_m03_n_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_xd2_m03n_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd2_m03n_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd2_m03n_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_xd2_m03n_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd2_m03n_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd2_m03n_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_xd2_m03n_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd2_m03n_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd2_m03n_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_xd2_m03n_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd2_m03n_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd2_m03n_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m03_n_xd2_m03n_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd2_m03n_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd2_m03n_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_xd2_m03n_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd2_m03n_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd2_m03n_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_xd2_m03n_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd2_m03n_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd2_m03n_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_xd2_m03n_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd2_m03n_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd2_m03n_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m03_n_xd2_m03n_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m03_n_xd2_m03n_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m03_n_xd2_m03n_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M04P_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m04_p_std_pack(
    uint8_t *dst_p,
    const struct A123_m04_p_std_t *src_p,
    size_t size);

/**
 * Unpack message M04P_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m04_p_std_unpack(
    struct A123_m04_p_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_std_m04p_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_m04p_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_m04p_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M04P_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m04_p_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m04_p_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M04P_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m04_p_xd1_unpack(
    struct A123_m04_p_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_xd1_m04p_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd1_m04p_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd1_m04p_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_xd1_m04p_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd1_m04p_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd1_m04p_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_xd1_m04p_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd1_m04p_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd1_m04p_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_xd1_m04p_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd1_m04p_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd1_m04p_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_xd1_m04p_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd1_m04p_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd1_m04p_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_xd1_m04p_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd1_m04p_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd1_m04p_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_xd1_m04p_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd1_m04p_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd1_m04p_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_xd1_m04p_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd1_m04p_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd1_m04p_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M04P_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m04_p_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m04_p_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M04P_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m04_p_xd2_unpack(
    struct A123_m04_p_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_xd2_m04p_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd2_m04p_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd2_m04p_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_xd2_m04p_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd2_m04p_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd2_m04p_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_xd2_m04p_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd2_m04p_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd2_m04p_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_xd2_m04p_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd2_m04p_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd2_m04p_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m04_p_xd2_m04p_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd2_m04p_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd2_m04p_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_xd2_m04p_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd2_m04p_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd2_m04p_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_xd2_m04p_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd2_m04p_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd2_m04p_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_xd2_m04p_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd2_m04p_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd2_m04p_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m04_p_xd2_m04p_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m04_p_xd2_m04p_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m04_p_xd2_m04p_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M05N_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m05_n_std_pack(
    uint8_t *dst_p,
    const struct A123_m05_n_std_t *src_p,
    size_t size);

/**
 * Unpack message M05N_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m05_n_std_unpack(
    struct A123_m05_n_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_std_m05n_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_m05n_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_m05n_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M05N_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m05_n_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m05_n_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M05N_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m05_n_xd1_unpack(
    struct A123_m05_n_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_xd1_m05n_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd1_m05n_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd1_m05n_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_xd1_m05n_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd1_m05n_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd1_m05n_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_xd1_m05n_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd1_m05n_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd1_m05n_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_xd1_m05n_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd1_m05n_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd1_m05n_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_xd1_m05n_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd1_m05n_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd1_m05n_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_xd1_m05n_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd1_m05n_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd1_m05n_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_xd1_m05n_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd1_m05n_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd1_m05n_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_xd1_m05n_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd1_m05n_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd1_m05n_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M05N_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m05_n_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m05_n_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M05N_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m05_n_xd2_unpack(
    struct A123_m05_n_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_xd2_m05n_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd2_m05n_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd2_m05n_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_xd2_m05n_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd2_m05n_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd2_m05n_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_xd2_m05n_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd2_m05n_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd2_m05n_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_xd2_m05n_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd2_m05n_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd2_m05n_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m05_n_xd2_m05n_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd2_m05n_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd2_m05n_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_xd2_m05n_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd2_m05n_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd2_m05n_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_xd2_m05n_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd2_m05n_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd2_m05n_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_xd2_m05n_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd2_m05n_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd2_m05n_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m05_n_xd2_m05n_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m05_n_xd2_m05n_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m05_n_xd2_m05n_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M06P_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m06_p_std_pack(
    uint8_t *dst_p,
    const struct A123_m06_p_std_t *src_p,
    size_t size);

/**
 * Unpack message M06P_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m06_p_std_unpack(
    struct A123_m06_p_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_std_m06p_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_m06p_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_m06p_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M06P_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m06_p_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m06_p_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M06P_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m06_p_xd1_unpack(
    struct A123_m06_p_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_xd1_m06p_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd1_m06p_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd1_m06p_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_xd1_m06p_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd1_m06p_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd1_m06p_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_xd1_m06p_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd1_m06p_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd1_m06p_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_xd1_m06p_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd1_m06p_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd1_m06p_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_xd1_m06p_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd1_m06p_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd1_m06p_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_xd1_m06p_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd1_m06p_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd1_m06p_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_xd1_m06p_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd1_m06p_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd1_m06p_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_xd1_m06p_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd1_m06p_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd1_m06p_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M06P_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m06_p_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m06_p_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M06P_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m06_p_xd2_unpack(
    struct A123_m06_p_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_xd2_m06p_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd2_m06p_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd2_m06p_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_xd2_m06p_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd2_m06p_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd2_m06p_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_xd2_m06p_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd2_m06p_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd2_m06p_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_xd2_m06p_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd2_m06p_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd2_m06p_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m06_p_xd2_m06p_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd2_m06p_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd2_m06p_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_xd2_m06p_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd2_m06p_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd2_m06p_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_xd2_m06p_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd2_m06p_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd2_m06p_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_xd2_m06p_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd2_m06p_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd2_m06p_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m06_p_xd2_m06p_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m06_p_xd2_m06p_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m06_p_xd2_m06p_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M07N_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m07_n_std_pack(
    uint8_t *dst_p,
    const struct A123_m07_n_std_t *src_p,
    size_t size);

/**
 * Unpack message M07N_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m07_n_std_unpack(
    struct A123_m07_n_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_std_m07n_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_m07n_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_m07n_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M07N_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m07_n_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m07_n_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M07N_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m07_n_xd1_unpack(
    struct A123_m07_n_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_xd1_m07n_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd1_m07n_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd1_m07n_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_xd1_m07n_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd1_m07n_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd1_m07n_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_xd1_m07n_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd1_m07n_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd1_m07n_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_xd1_m07n_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd1_m07n_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd1_m07n_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_xd1_m07n_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd1_m07n_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd1_m07n_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_xd1_m07n_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd1_m07n_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd1_m07n_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_xd1_m07n_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd1_m07n_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd1_m07n_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_xd1_m07n_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd1_m07n_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd1_m07n_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M07N_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m07_n_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m07_n_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M07N_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m07_n_xd2_unpack(
    struct A123_m07_n_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_xd2_m07n_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd2_m07n_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd2_m07n_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_xd2_m07n_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd2_m07n_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd2_m07n_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_xd2_m07n_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd2_m07n_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd2_m07n_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_xd2_m07n_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd2_m07n_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd2_m07n_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m07_n_xd2_m07n_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd2_m07n_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd2_m07n_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_xd2_m07n_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd2_m07n_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd2_m07n_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_xd2_m07n_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd2_m07n_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd2_m07n_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_xd2_m07n_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd2_m07n_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd2_m07n_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m07_n_xd2_m07n_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m07_n_xd2_m07n_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m07_n_xd2_m07n_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M08P_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m08_p_std_pack(
    uint8_t *dst_p,
    const struct A123_m08_p_std_t *src_p,
    size_t size);

/**
 * Unpack message M08P_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m08_p_std_unpack(
    struct A123_m08_p_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_std_m08p_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_m08p_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_m08p_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M08P_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m08_p_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m08_p_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M08P_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m08_p_xd1_unpack(
    struct A123_m08_p_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_xd1_m08p_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd1_m08p_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd1_m08p_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_xd1_m08p_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd1_m08p_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd1_m08p_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_xd1_m08p_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd1_m08p_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd1_m08p_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_xd1_m08p_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd1_m08p_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd1_m08p_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_xd1_m08p_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd1_m08p_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd1_m08p_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_xd1_m08p_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd1_m08p_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd1_m08p_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_xd1_m08p_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd1_m08p_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd1_m08p_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_xd1_m08p_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd1_m08p_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd1_m08p_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M08P_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m08_p_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m08_p_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M08P_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m08_p_xd2_unpack(
    struct A123_m08_p_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_xd2_m08p_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd2_m08p_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd2_m08p_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_xd2_m08p_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd2_m08p_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd2_m08p_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_xd2_m08p_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd2_m08p_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd2_m08p_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_xd2_m08p_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd2_m08p_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd2_m08p_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m08_p_xd2_m08p_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd2_m08p_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd2_m08p_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_xd2_m08p_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd2_m08p_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd2_m08p_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_xd2_m08p_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd2_m08p_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd2_m08p_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_xd2_m08p_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd2_m08p_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd2_m08p_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m08_p_xd2_m08p_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m08_p_xd2_m08p_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m08_p_xd2_m08p_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M09N_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m09_n_std_pack(
    uint8_t *dst_p,
    const struct A123_m09_n_std_t *src_p,
    size_t size);

/**
 * Unpack message M09N_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m09_n_std_unpack(
    struct A123_m09_n_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_std_m09n_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_m09n_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_m09n_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M09N_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m09_n_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m09_n_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M09N_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m09_n_xd1_unpack(
    struct A123_m09_n_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_xd1_m09n_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd1_m09n_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd1_m09n_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_xd1_m09n_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd1_m09n_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd1_m09n_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_xd1_m09n_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd1_m09n_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd1_m09n_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_xd1_m09n_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd1_m09n_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd1_m09n_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_xd1_m09n_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd1_m09n_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd1_m09n_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_xd1_m09n_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd1_m09n_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd1_m09n_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_xd1_m09n_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd1_m09n_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd1_m09n_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_xd1_m09n_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd1_m09n_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd1_m09n_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M09N_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m09_n_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m09_n_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M09N_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m09_n_xd2_unpack(
    struct A123_m09_n_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_xd2_m09n_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd2_m09n_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd2_m09n_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_xd2_m09n_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd2_m09n_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd2_m09n_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_xd2_m09n_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd2_m09n_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd2_m09n_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_xd2_m09n_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd2_m09n_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd2_m09n_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m09_n_xd2_m09n_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd2_m09n_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd2_m09n_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_xd2_m09n_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd2_m09n_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd2_m09n_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_xd2_m09n_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd2_m09n_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd2_m09n_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_xd2_m09n_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd2_m09n_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd2_m09n_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m09_n_xd2_m09n_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m09_n_xd2_m09n_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m09_n_xd2_m09n_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M10P_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m10_p_std_pack(
    uint8_t *dst_p,
    const struct A123_m10_p_std_t *src_p,
    size_t size);

/**
 * Unpack message M10P_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m10_p_std_unpack(
    struct A123_m10_p_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_std_m10p_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_m10p_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_m10p_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M10P_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m10_p_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m10_p_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M10P_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m10_p_xd1_unpack(
    struct A123_m10_p_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_xd1_m10p_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd1_m10p_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd1_m10p_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_xd1_m10p_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd1_m10p_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd1_m10p_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_xd1_m10p_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd1_m10p_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd1_m10p_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_xd1_m10p_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd1_m10p_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd1_m10p_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_xd1_m10p_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd1_m10p_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd1_m10p_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_xd1_m10p_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd1_m10p_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd1_m10p_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_xd1_m10p_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd1_m10p_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd1_m10p_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_xd1_m10p_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd1_m10p_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd1_m10p_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M10P_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m10_p_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m10_p_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M10P_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m10_p_xd2_unpack(
    struct A123_m10_p_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_xd2_m10p_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd2_m10p_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd2_m10p_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_xd2_m10p_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd2_m10p_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd2_m10p_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_xd2_m10p_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd2_m10p_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd2_m10p_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_xd2_m10p_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd2_m10p_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd2_m10p_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m10_p_xd2_m10p_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd2_m10p_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd2_m10p_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_xd2_m10p_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd2_m10p_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd2_m10p_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_xd2_m10p_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd2_m10p_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd2_m10p_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_xd2_m10p_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd2_m10p_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd2_m10p_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m10_p_xd2_m10p_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m10_p_xd2_m10p_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m10_p_xd2_m10p_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M11N_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m11_n_std_pack(
    uint8_t *dst_p,
    const struct A123_m11_n_std_t *src_p,
    size_t size);

/**
 * Unpack message M11N_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m11_n_std_unpack(
    struct A123_m11_n_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_std_m11n_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_m11n_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_m11n_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M11N_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m11_n_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m11_n_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M11N_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m11_n_xd1_unpack(
    struct A123_m11_n_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_xd1_m11n_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd1_m11n_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd1_m11n_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_xd1_m11n_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd1_m11n_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd1_m11n_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_xd1_m11n_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd1_m11n_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd1_m11n_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_xd1_m11n_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd1_m11n_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd1_m11n_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_xd1_m11n_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd1_m11n_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd1_m11n_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_xd1_m11n_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd1_m11n_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd1_m11n_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_xd1_m11n_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd1_m11n_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd1_m11n_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_xd1_m11n_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd1_m11n_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd1_m11n_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M11N_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m11_n_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m11_n_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M11N_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m11_n_xd2_unpack(
    struct A123_m11_n_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_xd2_m11n_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd2_m11n_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd2_m11n_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_xd2_m11n_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd2_m11n_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd2_m11n_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_xd2_m11n_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd2_m11n_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd2_m11n_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_xd2_m11n_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd2_m11n_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd2_m11n_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m11_n_xd2_m11n_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd2_m11n_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd2_m11n_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_xd2_m11n_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd2_m11n_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd2_m11n_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_xd2_m11n_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd2_m11n_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd2_m11n_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_xd2_m11n_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd2_m11n_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd2_m11n_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m11_n_xd2_m11n_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m11_n_xd2_m11n_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m11_n_xd2_m11n_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M12P_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m12_p_std_pack(
    uint8_t *dst_p,
    const struct A123_m12_p_std_t *src_p,
    size_t size);

/**
 * Unpack message M12P_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m12_p_std_unpack(
    struct A123_m12_p_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_std_m12p_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_m12p_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_m12p_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M12P_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m12_p_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m12_p_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M12P_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m12_p_xd1_unpack(
    struct A123_m12_p_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_xd1_m12p_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd1_m12p_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd1_m12p_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_xd1_m12p_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd1_m12p_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd1_m12p_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_xd1_m12p_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd1_m12p_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd1_m12p_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_xd1_m12p_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd1_m12p_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd1_m12p_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_xd1_m12p_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd1_m12p_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd1_m12p_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_xd1_m12p_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd1_m12p_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd1_m12p_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_xd1_m12p_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd1_m12p_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd1_m12p_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_xd1_m12p_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd1_m12p_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd1_m12p_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M12P_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m12_p_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m12_p_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M12P_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m12_p_xd2_unpack(
    struct A123_m12_p_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_xd2_m12p_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd2_m12p_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd2_m12p_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_xd2_m12p_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd2_m12p_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd2_m12p_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_xd2_m12p_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd2_m12p_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd2_m12p_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_xd2_m12p_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd2_m12p_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd2_m12p_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m12_p_xd2_m12p_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd2_m12p_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd2_m12p_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_xd2_m12p_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd2_m12p_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd2_m12p_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_xd2_m12p_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd2_m12p_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd2_m12p_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_xd2_m12p_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd2_m12p_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd2_m12p_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m12_p_xd2_m12p_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m12_p_xd2_m12p_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m12_p_xd2_m12p_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M13N_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m13_n_std_pack(
    uint8_t *dst_p,
    const struct A123_m13_n_std_t *src_p,
    size_t size);

/**
 * Unpack message M13N_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m13_n_std_unpack(
    struct A123_m13_n_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_std_m13n_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_m13n_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_m13n_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M13N_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m13_n_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m13_n_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M13N_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m13_n_xd1_unpack(
    struct A123_m13_n_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_xd1_m13n_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd1_m13n_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd1_m13n_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_xd1_m13n_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd1_m13n_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd1_m13n_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_xd1_m13n_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd1_m13n_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd1_m13n_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_xd1_m13n_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd1_m13n_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd1_m13n_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_xd1_m13n_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd1_m13n_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd1_m13n_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_xd1_m13n_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd1_m13n_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd1_m13n_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_xd1_m13n_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd1_m13n_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd1_m13n_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_xd1_m13n_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd1_m13n_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd1_m13n_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M13N_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m13_n_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m13_n_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M13N_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m13_n_xd2_unpack(
    struct A123_m13_n_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_xd2_m13n_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd2_m13n_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd2_m13n_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_xd2_m13n_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd2_m13n_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd2_m13n_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_xd2_m13n_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd2_m13n_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd2_m13n_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_xd2_m13n_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd2_m13n_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd2_m13n_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m13_n_xd2_m13n_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd2_m13n_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd2_m13n_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_xd2_m13n_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd2_m13n_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd2_m13n_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_xd2_m13n_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd2_m13n_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd2_m13n_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_xd2_m13n_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd2_m13n_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd2_m13n_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m13_n_xd2_m13n_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m13_n_xd2_m13n_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m13_n_xd2_m13n_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M14P_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m14_p_std_pack(
    uint8_t *dst_p,
    const struct A123_m14_p_std_t *src_p,
    size_t size);

/**
 * Unpack message M14P_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m14_p_std_unpack(
    struct A123_m14_p_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_std_m14p_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_m14p_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_m14p_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M14P_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m14_p_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m14_p_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M14P_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m14_p_xd1_unpack(
    struct A123_m14_p_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_xd1_m14p_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd1_m14p_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd1_m14p_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_xd1_m14p_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd1_m14p_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd1_m14p_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_xd1_m14p_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd1_m14p_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd1_m14p_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_xd1_m14p_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd1_m14p_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd1_m14p_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_xd1_m14p_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd1_m14p_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd1_m14p_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_xd1_m14p_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd1_m14p_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd1_m14p_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_xd1_m14p_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd1_m14p_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd1_m14p_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_xd1_m14p_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd1_m14p_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd1_m14p_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M14P_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m14_p_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m14_p_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M14P_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m14_p_xd2_unpack(
    struct A123_m14_p_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_xd2_m14p_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd2_m14p_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd2_m14p_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_xd2_m14p_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd2_m14p_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd2_m14p_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_xd2_m14p_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd2_m14p_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd2_m14p_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_xd2_m14p_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd2_m14p_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd2_m14p_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m14_p_xd2_m14p_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd2_m14p_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd2_m14p_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_xd2_m14p_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd2_m14p_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd2_m14p_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_xd2_m14p_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd2_m14p_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd2_m14p_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_xd2_m14p_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd2_m14p_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd2_m14p_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m14_p_xd2_m14p_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m14_p_xd2_m14p_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m14_p_xd2_m14p_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message M15N_STD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m15_n_std_pack(
    uint8_t *dst_p,
    const struct A123_m15_n_std_t *src_p,
    size_t size);

/**
 * Unpack message M15N_STD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m15_n_std_unpack(
    struct A123_m15_n_std_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_response_id_std_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_response_id_std_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_response_id_std_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_mux_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_mux_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_mux_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_t0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_t0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_t0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_t1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_t1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_t1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_t2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_t2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_t2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_t3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_t3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_t3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_no_can_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_no_can_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_no_can_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_bal_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_bal_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_bal_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_cell_count_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_cell_count_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_cell_count_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_sw_ver_major_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_sw_ver_major_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_sw_ver_major_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_sw_ver_minor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_sw_ver_minor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_sw_ver_minor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_sw_ver_build_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_sw_ver_build_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_sw_ver_build_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_no_can_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_no_can_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_no_can_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_v_compare_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_v_compare_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_v_compare_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_v_ref_drift_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_v_ref_drift_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_v_ref_drift_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_overvoltage_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_overvoltage_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_overvoltage_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_cell_overvolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_cell_overvolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_cell_overvolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_ram_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_ram_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_ram_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_cell_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_cell_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_cell_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_rom_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_rom_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_rom_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_mod_undervolt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_mod_undervolt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_mod_undervolt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_err_nvm_check_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_err_nvm_check_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_err_nvm_check_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_std_mod_v_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_mod_v_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_mod_v_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_mod_tmp_chn_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_mod_tmp_chn_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_mod_tmp_chn_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_std_mod_v_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_mod_v_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_mod_v_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_fault_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_fault_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_fault_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_fault_in_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_fault_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_fault_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_std_m15n_error_flag_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_m15n_error_flag_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_m15n_error_flag_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_std_mod_v_ave_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_std_mod_v_ave_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_std_mod_v_ave_is_in_range(uint16_t value);

/**
 * Pack message M15N_XD1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m15_n_xd1_pack(
    uint8_t *dst_p,
    const struct A123_m15_n_xd1_t *src_p,
    size_t size);

/**
 * Unpack message M15N_XD1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m15_n_xd1_unpack(
    struct A123_m15_n_xd1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_xd1_m15n_response_id_xd1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd1_m15n_response_id_xd1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd1_m15n_response_id_xd1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_xd1_m15n_bal_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd1_m15n_bal_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd1_m15n_bal_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_xd1_m15n_bal_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd1_m15n_bal_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd1_m15n_bal_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_xd1_m15n_bal_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd1_m15n_bal_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd1_m15n_bal_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_xd1_m15n_v_mbb_total_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd1_m15n_v_mbb_total_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd1_m15n_v_mbb_total_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_xd1_m15n_v_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd1_m15n_v_cell_01_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd1_m15n_v_cell_01_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_xd1_m15n_v_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd1_m15n_v_cell_02_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd1_m15n_v_cell_02_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_xd1_m15n_v_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd1_m15n_v_cell_03_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd1_m15n_v_cell_03_is_in_range(uint16_t value);

/**
 * Pack message M15N_XD2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_m15_n_xd2_pack(
    uint8_t *dst_p,
    const struct A123_m15_n_xd2_t *src_p,
    size_t size);

/**
 * Unpack message M15N_XD2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_m15_n_xd2_unpack(
    struct A123_m15_n_xd2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_xd2_m15n_response_id_xd2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd2_m15n_response_id_xd2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd2_m15n_response_id_xd2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_xd2_m15n_bal_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd2_m15n_bal_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd2_m15n_bal_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_xd2_m15n_bal_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd2_m15n_bal_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd2_m15n_bal_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_xd2_m15n_bal_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd2_m15n_bal_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd2_m15n_bal_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_m15_n_xd2_m15n_bal_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd2_m15n_bal_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd2_m15n_bal_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_xd2_m15n_v_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd2_m15n_v_cell_04_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd2_m15n_v_cell_04_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_xd2_m15n_v_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd2_m15n_v_cell_05_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd2_m15n_v_cell_05_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_xd2_m15n_v_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd2_m15n_v_cell_06_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd2_m15n_v_cell_06_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_m15_n_xd2_m15n_v_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_m15_n_xd2_m15n_v_cell_07_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_m15_n_xd2_m15n_v_cell_07_is_in_range(uint16_t value);

/**
 * Pack message BCM_CMD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_bcm_cmd_pack(
    uint8_t *dst_p,
    const struct A123_bcm_cmd_t *src_p,
    size_t size);

/**
 * Unpack message BCM_CMD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_bcm_cmd_unpack(
    struct A123_bcm_cmd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_request_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_request_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_request_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_request_type_old_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_request_type_old_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_request_type_old_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_bcm_cmd_bcm_v_balance_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_v_balance_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_v_balance_target_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_leakage_cmd_csm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_leakage_cmd_csm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_leakage_cmd_csm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_leakage_cmd_idm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_leakage_cmd_idm_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_leakage_cmd_idm_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_request_type_new_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_request_type_new_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_request_type_new_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_message_format_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_message_format_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_message_format_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m01n_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m01n_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m01n_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m02p_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m02p_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m02p_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m03n_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m03n_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m03n_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m04p_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m04p_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m04p_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m05n_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m05n_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m05n_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m06p_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m06p_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m06p_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m07n_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m07n_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m07n_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m08p_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m08p_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m08p_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m09n_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m09n_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m09n_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m10p_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m10p_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m10p_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m11n_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m11n_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m11n_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m12p_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m12p_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m12p_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m13n_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m13n_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m13n_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m14p_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m14p_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m14p_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m15n_bal_power_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m15n_bal_power_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m15n_bal_power_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_balance_cmd_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_balance_cmd_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_balance_cmd_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m01n_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m01n_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m01n_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m02p_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m02p_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m02p_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m03n_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m03n_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m03n_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m04p_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m04p_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m04p_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m05n_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m05n_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m05n_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m06p_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m06p_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m06p_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m07n_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m07n_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m07n_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m08p_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m08p_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m08p_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m09n_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m09n_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m09n_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m10p_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m10p_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m10p_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m11n_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m11n_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m11n_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m12p_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m12p_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m12p_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m13n_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m13n_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m13n_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m14p_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m14p_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m14p_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m15n_bal_diag_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m15n_bal_diag_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m15n_bal_diag_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m01n_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m01n_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m01n_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m02p_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m02p_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m02p_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m03n_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m03n_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m03n_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m04p_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m04p_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m04p_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m05n_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m05n_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m05n_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m06p_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m06p_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m06p_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m07n_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m07n_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m07n_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m08p_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m08p_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m08p_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m09n_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m09n_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m09n_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m10p_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m10p_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m10p_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m11n_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m11n_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m11n_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m12p_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m12p_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m12p_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m13n_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m13n_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m13n_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m14p_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m14p_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m14p_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m15n_bal_ena_cell_07_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m15n_bal_ena_cell_07_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m15n_bal_ena_cell_07_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m01n_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m01n_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m01n_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m02p_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m02p_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m02p_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m03n_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m03n_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m03n_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m04p_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m04p_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m04p_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m05n_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m05n_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m05n_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m06p_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m06p_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m06p_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m07n_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m07n_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m07n_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m08p_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m08p_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m08p_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m09n_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m09n_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m09n_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m10p_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m10p_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m10p_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m11n_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m11n_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m11n_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m12p_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m12p_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m12p_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m13n_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m13n_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m13n_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m14p_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m14p_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m14p_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m15n_bal_ena_cell_06_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m15n_bal_ena_cell_06_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m15n_bal_ena_cell_06_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m01n_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m01n_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m01n_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m02p_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m02p_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m02p_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m03n_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m03n_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m03n_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m04p_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m04p_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m04p_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m05n_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m05n_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m05n_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m06p_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m06p_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m06p_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m07n_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m07n_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m07n_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m08p_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m08p_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m08p_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m09n_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m09n_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m09n_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m10p_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m10p_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m10p_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m11n_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m11n_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m11n_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m12p_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m12p_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m12p_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m13n_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m13n_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m13n_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m14p_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m14p_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m14p_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m15n_bal_ena_cell_05_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m15n_bal_ena_cell_05_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m15n_bal_ena_cell_05_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m01n_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m01n_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m01n_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m02p_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m02p_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m02p_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m03n_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m03n_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m03n_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m04p_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m04p_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m04p_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m05n_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m05n_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m05n_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m06p_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m06p_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m06p_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m07n_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m07n_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m07n_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m08p_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m08p_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m08p_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m09n_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m09n_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m09n_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m10p_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m10p_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m10p_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m11n_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m11n_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m11n_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m12p_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m12p_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m12p_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m13n_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m13n_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m13n_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m14p_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m14p_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m14p_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m15n_bal_ena_cell_04_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m15n_bal_ena_cell_04_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m15n_bal_ena_cell_04_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m01n_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m01n_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m01n_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m02p_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m02p_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m02p_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m03n_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m03n_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m03n_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m04p_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m04p_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m04p_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m05n_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m05n_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m05n_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m06p_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m06p_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m06p_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m07n_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m07n_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m07n_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m08p_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m08p_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m08p_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m09n_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m09n_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m09n_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m10p_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m10p_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m10p_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m11n_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m11n_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m11n_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m12p_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m12p_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m12p_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m13n_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m13n_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m13n_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m14p_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m14p_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m14p_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m15n_bal_ena_cell_03_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m15n_bal_ena_cell_03_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m15n_bal_ena_cell_03_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m01n_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m01n_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m01n_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m02p_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m02p_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m02p_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m03n_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m03n_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m03n_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m04p_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m04p_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m04p_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m05n_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m05n_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m05n_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m06p_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m06p_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m06p_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m07n_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m07n_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m07n_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m08p_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m08p_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m08p_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m09n_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m09n_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m09n_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m10p_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m10p_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m10p_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m11n_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m11n_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m11n_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m12p_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m12p_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m12p_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m13n_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m13n_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m13n_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m14p_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m14p_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m14p_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m15n_bal_ena_cell_02_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m15n_bal_ena_cell_02_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m15n_bal_ena_cell_02_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m01n_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m01n_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m01n_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m02p_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m02p_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m02p_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m03n_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m03n_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m03n_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m04p_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m04p_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m04p_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m05n_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m05n_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m05n_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m06p_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m06p_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m06p_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m07n_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m07n_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m07n_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m08p_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m08p_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m08p_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m09n_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m09n_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m09n_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m10p_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m10p_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m10p_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m11n_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m11n_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m11n_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m12p_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m12p_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m12p_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m13n_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m13n_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m13n_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m14p_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m14p_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m14p_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_cmd_bcm_m15n_bal_ena_cell_01_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_cmd_bcm_m15n_bal_ena_cell_01_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_cmd_bcm_m15n_bal_ena_cell_01_is_in_range(uint8_t value);

/**
 * Pack message BCM_DIAG_REQ.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_bcm_diag_req_pack(
    uint8_t *dst_p,
    const struct A123_bcm_diag_req_t *src_p,
    size_t size);

/**
 * Unpack message BCM_DIAG_REQ.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_bcm_diag_req_unpack(
    struct A123_bcm_diag_req_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_diag_req_diag_length_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_diag_req_diag_length_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_diag_req_diag_length_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_diag_req_diag_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_diag_req_diag_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_diag_req_diag_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_bcm_diag_req_diag_did_bcm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_diag_req_diag_did_bcm_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_diag_req_diag_did_bcm_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float A123_bcm_diag_req_diag_float_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_diag_req_diag_float_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_diag_req_diag_float_is_in_range(float value);

/**
 * Pack message BCM_DIAG_RSP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_bcm_diag_rsp_pack(
    uint8_t *dst_p,
    const struct A123_bcm_diag_rsp_t *src_p,
    size_t size);

/**
 * Unpack message BCM_DIAG_RSP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_bcm_diag_rsp_unpack(
    struct A123_bcm_diag_rsp_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_diag_rsp_diag_length_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_diag_rsp_diag_length_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_diag_rsp_diag_length_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t A123_bcm_diag_rsp_diag_sid_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_diag_rsp_diag_sid_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_diag_rsp_diag_sid_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t A123_bcm_diag_rsp_diag_did_bcm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_diag_rsp_diag_did_bcm_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_diag_rsp_diag_did_bcm_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
float A123_bcm_diag_rsp_diag_float_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double A123_bcm_diag_rsp_diag_float_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool A123_bcm_diag_rsp_diag_float_is_in_range(float value);

/**
 * Pack message BCM_IDENTIFY_POR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int A123_bcm_identify_por_pack(
    uint8_t *dst_p,
    const struct A123_bcm_identify_por_t *src_p,
    size_t size);

/**
 * Unpack message BCM_IDENTIFY_POR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int A123_bcm_identify_por_unpack(
    struct A123_bcm_identify_por_t *dst_p,
    const uint8_t *src_p,
    size_t size);


#ifdef __cplusplus
}
#endif

#endif
